#summary Guidance on crypto implementation
#sidebar TableOfContents

Here are my latest greatest thoughts for ESAPI for PHP:

==First, we need cryptographic key management functions.==

Let us keep it simple, assume there are manually-entered keys in ESAPI.xml...
{{{
public km_setSymmetricKey($keyname, $ivname = null) //does not return a value, sets private vars
public km_setAsymmetricKeyPair($keyname)
public km_setMessageAuthenticationKeys($keyname) //includes precomputed subkeys
}}}
E.g.,

||*ESAPI.xml*|| || || || ||
|| || Encryptor || || || ||
|| || || ... || ... || ||
|| || || Keys || || ||
|| || || || AES_128_CBC_MY_KEY || 4278b840fb44aaa757c1bf04acbe1a3e (this would be the actual key in the reference implementation, could in one's own implementation be e.g. additional identifiers to use to retrieve a key from somewhere) ||
|| || || || AES_128_CBC_MY_IV || 57f02a5c5339daeb0a2908a06ac6393f ||
|| || || || ... || ... ||
|| || || || MasterSalt || A17FED27EAA842282862FF7C1B9C8395A26AC320 ||
|| || || || ... || ... ||

We don't need any key import/export functionality for a first release.

==Second, we need cryptographic operation functions.==

We need some definitions...
{{{
const ESAPI_CRYPTO_OP_SYMMETRIC_KEY_ENCRYPT_ASCII_HEX
const ESAPI_CRYPTO_OP_SYMMETRIC_KEY_DECRYPT_ASCII_HEX
const ESAPI_CRYPTO_OP_ASYMMETRIC_KEY_SIGN_CREATE_BASE64_CMS
const ESAPI_CRYPTO_OP_ASYMMETRIC_KEY_VERIFY_BASE64_CMS
}}}
Here are the supported configuration values to validate as input from ESAPI.xml, only 1 - 2 will be supported in first release...
{{{
private ESAPI_CRYPTO_MODE_SHA1
private ESAPI_CRYPTO_MODE_SHA224
private ESAPI_CRYPTO_MODE_SHA384
private ESAPI_CRYPTO_MODE_SHA512
private ESAPI_CRYPTO_MODE_AES_128_ECB
private ESAPI_CRYPTO_MODE_AES_128_CBC
private ESAPI_CRYPTO_MODE_AES_128_CFB
private ESAPI_CRYPTO_MODE_AES_128_CTR
private ESAPI_CRYPTO_MODE_AES_128_OFB
private ESAPI_CRYPTO_MODE_AES_192_ECB
private ESAPI_CRYPTO_MODE_AES_192_CBC
private ESAPI_CRYPTO_MODE_AES_192_CFB
private ESAPI_CRYPTO_MODE_AES_192_CTR
private ESAPI_CRYPTO_MODE_AES_192_OFB
private ESAPI_CRYPTO_MODE_AES_256_ECB
private ESAPI_CRYPTO_MODE_AES_256_CBC
private ESAPI_CRYPTO_MODE_AES_256_CFB
private ESAPI_CRYPTO_MODE_AES_256_CTR
private ESAPI_CRYPTO_MODE_AES_256_OFB
private ESAPI_CRYPTO_MODE_3DES_KO1_TECB
private ESAPI_CRYPTO_MODE_3DES_KO1_TCBC
private ESAPI_CRYPTO_MODE_3DES_KO1_TCBC_I
private ESAPI_CRYPTO_MODE_3DES_KO1_TCFB
private ESAPI_CRYPTO_MODE_3DES_KO1_TCFB_P
private ESAPI_CRYPTO_MODE_3DES_KO1_OFB
private ESAPI_CRYPTO_MODE_3DES_KO1_OFB_I
private ESAPI_CRYPTO_MODE_3DES_KO2_TCBC_I
private ESAPI_CRYPTO_MODE_3DES_KO2_TCFB
private ESAPI_CRYPTO_MODE_3DES_KO2_TCFB_P
private ESAPI_CRYPTO_MODE_3DES_KO2_OFB
private ESAPI_CRYPTO_MODE_3DES_KO2_OFB_I
//... continue on, e.g. for signatures, according to FIPS 140-2, as above

private $_algorithm_symmetric //combination of algorithm/key/mode, set using ESAPI.xml
private $_algorithm_asymmetric
private $_algorithm_shs //hash algorithm, set using ESAPI.xml
private $_algorithm_rng
private $_algorithm_mac

private $_symmetric_key
private $_symmetric_iv
private $_asymmetric_public_key
private $_asymmetric_private_key
private $_mac_symmetric_key
private $_mac_subkey1
private $_mac_subkey2

private _op_init() //called by constructor, sets available algorithm/key/mode
public op_symmetric($data, $operation)
public op_asymmetric($data, $operation)
public op_hash($data, $salt = null) //maybe later, add the ability to do hash updates
public op_random() //DefaultRandomizer should be calling this, which in turn will call mt_rand (for now)
public op_mac($data)
}}}

E.g.,

||*ESAPI.xml*|| || || || ||
|| || Encryptor || || || ||
|| || || ... || ... || ||
|| || || Modes || || ||
|| || || || SymmetricAlgorithm || ESAPI_CRYPTO_MODE_AES_128_CBC ||
|| || || || AsymmetricAlgorithm || ... ||
|| || || || HashAlgorithm || ESAPI_CRYPTO_MODE_SHA224 ||
|| || || || RandomAlgorithm || ... ||
|| || || || MessageAuthenticationAlgorithm || ... ||
|| || || || ... || ... ||

E.g., op_symmetric, e.g. ESAPI_CRYPTO_OP_SYMMETRIC_KEY_ENCRYPT_ASCII_HEX, inputs/outputs plain-old ASCII hex characters (e.g. 32 hex chars = 128 bit key)
{{{
KEY = 4278b840fb44aaa757c1bf04acbe1a3e
IV = 57f02a5c5339daeb0a2908a06ac6393f
PLAINTEXT = 3c888bbbb1a8eb9f3e9b87acaad986c466e2f7071c83083b8a557971918850e5
CIPHERTEXT = 479c89ec14bc98994e62b2c705b5014e175bd7832e7e60a1e92aac568a861eb7
}}}
Signatures should use [http://www.ietf.org/rfc/rfc3852.txt CMS (i.e. RFC 3852)] and they should be input/output in base 64.
 
==So our key management policy would look something like...==

||*Key/CSP*||*Type*||*Generation*||*Storage & Zeroization*||*Use*||
||...||...||...||...||...||
|| Keys/AES_.., Keys/3DES_.. || 128-bit AES key || Externally generated || Stored as plaintext on disk || Encrypts application data according to key purpose ||
|| Keys/MasterSalt || Configurable-length salt || Externally generated || Stored as plaintext on disk || Used to salt password hashes ||
|| Keys/HMAC_SHA1_.. || HMAC SHA-1 keys || Externally generated || Stored as plaintext on disk || Secures application-specific traffic according to key purpose ||
||...||...||...||...||...||

==Where...==

||*Service*||*Description*||*Keys Accessed*||
|| FIPS mode enable/disable ESAPI.xml configuration setting || Enables/Disables FIPS mode for cryptomodules that require this configuration to be done programmatically ||None ||
|| op_symmetric || Performs symmetric key encryption using the key loaded from the ESAPI configuration file using km_getSymmetricKey || Keys/AES_.., Keys/3DES_.. ||
||...||...||...||